# 学童「ぬいぐるみLLMプラン（仮）」整理メモ（これまでの会話まとめ）

最終更新: 2026-01-12  
目的: 本プランを本格検討するために、ユーザーの文脈・検討してきた論点・現時点の合意/注意点を一枚に整理する。

---

## 1. ユーザーの文脈（前提）

- 職務/環境  
  - 学童（放課後児童クラブ）で勤務。子どもと日常的に接する現場。
- 技術背景  
  - Unityでゲーム開発。
  - エージェントを用いたコーディング作業の経験あり。
- 手元リソース  
  - 新: Mac mini (M4, 512GB, 32GB)
  - 旧: Mac mini (M4, 256GB, 16GB) …売却以外の活用を検討
    - 旧機は常時稼働の小型サーバ/開発インフラ機として転用しやすい、という方向性が出た。

---

## 2. 目標（やりたいこと）

学童の子どもたちが「慣れ親しめる」存在として、**ぬいぐるみ外装のロボット**（以下「ぬいぐるみLLM」）を作る。

想定機能（段階的に）
- 雑談・おしゃべり（子どもが話しかけると返す）
- リマインド/簡易スケジューリング  
  - 例: 「4時半に勉強する！」→「分かった、4時半に呼ぶね！」
- 子どもの出来事の「記憶」  
  - 会話から情報を抽出して保存（例: 「テストがうまくいかなかった」等）
  - 保存先: ローカルDB（SQLite等）

---

## 3. これまでの議論の要点（結論レベル）

### 3.1 実現性
- **技術的には現実的**。ただし難所は性能よりも運用・安全・音声環境（学童の騒音）・誤認識。
- スケジューリングはLLM必須ではなく、**抽出だけLLM、登録/通知は決定的なロジック**にすると安定。

### 3.2 構成の基本方針（推奨）
- **会話（同期）** と **記憶処理（非同期）** を分離する（二段構え）。
  - 会話の応答を遅くしない。
  - 記憶抽出の失敗/遅延があっても会話が継続する。

### 3.3 Codex CLIの位置づけ
- Codex CLIを「音声入力エンジン」にするのは不適。
- ただしユーザー案のように「橋渡し（記憶抽出のLLM呼び出し役）」として使うことは**可能**。
- ただしCodexは本来コーディングエージェントで権限が強くなりがちなので、**非対話・read-only・履歴/分析無効化等**の運用設計が重要。

### 3.4 プライバシーに関する注意（論点）
- 「ローカルにSQLite保存だからプライバシーが解決」という理解は、**“外部APIへ送るか”** と **“ローカル保管”** が別問題のため成立しない。
- 完全ローカルを目指すなら、**ローカル推論（OSS provider等）**に寄せる必要がある。
- ただし本件は法務/規約の最終判断が必要な領域であり、現場ルール（同意、掲示、保管期間、削除手続き等）を先に固めるのが前提。

---

## 4. 要件整理（仮）

### 4.1 機能要件
- 音声で対話（Push-to-talk推奨）
- 予定登録（「時間/内容」）→ 時刻に音声で呼びかけ
- 記憶（子どもの出来事）を抽出してDB保存
- 次回会話で「思い出し」を行い、自然な継続会話を実現

### 4.2 非機能要件
- 低遅延（会話は止めない）
- 誤認識/誤抽出に強い（嘘の記憶を増やさない）
- ログ・データ最小化（保存しない/短期TTL/アクセス権限）
- 現場運用可能（スタッフが介入できる、緊急停止できる）

---

## 5. 推奨アーキテクチャ（MVP→拡張）

### 5.1 コア: 二系統（同期/非同期）
1) **会話パス（同期）**
- 音声入力 → STT → 応答生成 → TTS → 音声出力

2) **記憶パス（非同期ワーカー）**
- 会話テキスト（turn）をキューに積む
- LLMで「記憶候補」を構造化抽出
- ルール/検証/重複排除
- SQLiteに保存（pending→confirmed）

### 5.2 キュー設計（例）
- 最小: SQLiteに `queue` テーブル（ポーリング）
- 拡張: Redis/RabbitMQ等（必要になってから）

### 5.3 「記憶」を壊れにくくする設計
- **事実**と**感想**を混ぜない  
  - 例: 「テストが良くなかった」→ 点数が低いと断定しない（本人の自己評価として保存）
- 2段階保存  
  - `pending`（要確認/確度低）→ `confirmed`（確度高/スタッフ確認済）→ `rejected`
- メタデータ必須
  - `source`: self_reported / staff_observed
  - `confidence`: 0.0〜1.0
  - `sensitivity`: low/medium/high
  - `expires_at`（TTL）

---

## 6. 推奨データモデル（SQLite例）

### 6.1 テーブル案
- `children`
  - `id`（内部ID）, `alias`（呼称、実名を避ける）, `created_at`
- `turns`
  - `turn_id`, `child_id`, `created_at`, `transcript`（残すなら短期TTL）, `transcript_hash`
- `memory_items`
  - `id`, `child_id`, `kind`, `summary`, `subject`, `source`, `confidence`, `sensitivity`, `status`,
    `created_at`, `expires_at`, `turn_id`

### 6.2 取得戦略（思い出し）
- 次回会話で参照するのは原則 `confirmed` のみ
- 直近N件＋有効期限内のみ（データ最小化）

---

## 7. Codex CLIを「記憶抽出の橋渡し」にする場合のガードレール

### 7.1 使い方の原則
- `codex exec` の**非対話**で呼び出す（ワーカー内）
- 出力は **JSON Schema** で固定（構造化抽出に限定）
- 可能な限り **read-only / sandbox** のまま運用

### 7.2 やらないこと（事故要因）
- `--full-auto`（編集許可）を抽出用途で使わない
- `--danger-full-access` 等の危険モードを使わない
- `--yolo`（承認/サンドボックスの危険なバイパス）を使わない

### 7.3 ローカル残留物の抑制
- 履歴ファイル（例: history.jsonl）を残さない設定
- 認証キャッシュの保護（可能ならキーチェーン等）
- 解析/テレメトリ送信の無効化を検討

### 7.4 完全ローカル化の方向
- クラウドへ送らない要件が強い場合:
  - `--oss` 等のローカル推論プロバイダを検討
  - 抽出は軽量モデル＋`pending`運用で現実解にする

---

## 8. 主要リスク（技術より運用が支配的）

- **誤抽出による「嘘の記憶」混入**
  - 対策: pending→confirmed、確度/ソース/TTL必須
- **個人情報・センシティブ情報の蓄積**
  - 対策: 保存対象を明示的に限定、短期保持、アクセス制御
- **学童の音環境での聞き間違い**
  - 対策: Push-to-talk、聞き返し、確認プロンプト
- **複数人の取り違え（誰の記憶か）**
  - 対策: 全体リマインド中心 / 物理トークン / スタッフ確定
- **規約・同意・掲示の未整備**
  - 対策: 先に運用ルール化（同意、保管期間、削除、監督）

---

## 9. 次に決めるべきこと（最大5つ）

1. **運用方針**
   - 子どもが直接話すのか / スタッフが介在するのか
   - いつ・どこで使うのか（常設/イベント/試験運用）
2. **保存方針**
   - 何を保存するか（予定のみ/出来事も/感情は？）
   - どれくらい保持するか（TTL）
3. **識別方針**
   - 子どもの識別方法（IDカード/NFC/ボタン/スタッフ選択/全体扱い）
4. **MVP範囲**
   - まずは「予定登録＋呼びかけ」だけにするか、記憶も入れるか
5. **LLM実装の選択**
   - クラウドAPI（監視ログ等の扱いを理解して運用） vs 完全ローカル（性能と精度のトレードオフ）
   - Codex CLIを橋渡しにするか、直接API/SDKで抽出するか

---

## 10. 参考: ここまでの設計思想（短いまとめ）

- 「会話の気持ちよさ」は同期パスで守る  
- 「記憶」は非同期で、確度・確認・期限を前提にする  
- 子ども向けは技術より運用（同意/最小化/監督/安全）が支配的  
- Codex CLIは使えるが、抽出用途では権限を最小化して事故確率を下げる

